using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Xunit;
using Xunit.Abstractions;

namespace SmartInsight.Tests.SQL.Security
{
    public class XssVulnerabilityTests : SecurityTestBase
    {
        private readonly List<string> _xssPayloads = new List<string>
        {
            "<script>alert('XSS')</script>",
            "<img src=\"x\" onerror=\"alert('XSS')\">",
            "<div onmouseover=\"alert('XSS')\">Hover me</div>",
            "javascript:alert('XSS')",
            "<body onload=\"alert('XSS')\">",
            "<svg/onload=alert('XSS')>",
            "\"><script>alert('XSS')</script>",
            "';alert('XSS')//",
            "<input value=\"blah\" onfocus=\"alert('XSS')\" autofocus>",
            "<a href=\"javascript:alert('XSS')\">Click me</a>"
        };

        public XssVulnerabilityTests(ITestOutputHelper output) : base(output)
        {
        }

        [Fact(Skip = "Integration test requiring API setup")]
        public async Task UserProvidedData_InResponseBody_ShouldBeEncoded()
        {
            // Arrange
            foreach (var payload in _xssPayloads)
            {
                // Create user profile with XSS payload
                var userProfile = new
                {
                    DisplayName = payload,
                    Bio = payload,
                    Website = payload
                };
                
                // Create the profile
                await PostJsonAsync("/api/v1/users/profile", userProfile);
                
                // Act - Get the profile back
                var response = await _client.GetAsync("/api/v1/users/profile");
                
                // Assert
                Assert.Equal(HttpStatusCode.OK, response.StatusCode);
                
                var content = await response.Content.ReadAsStringAsync();
                
                // Check if any of the dangerous XSS payload patterns are present in their raw form
                bool hasUnescapedXss = 
                    content.Contains("<script>") || 
                    content.Contains("onerror=") ||
                    content.Contains("onmouseover=") ||
                    content.Contains("javascript:") ||
                    content.Contains("onload=") ||
                    content.Contains("onfocus=");
                
                Assert.False(hasUnescapedXss, $"Unencoded XSS payload in response: {payload}");
                _output.WriteLine($"XSS payload correctly encoded in response: {payload}");
            }
        }

        [Fact(Skip = "Integration test requiring API setup")]
        public async Task UserProvidedData_InUrls_ShouldBeValidated()
        {
            // Arrange
            foreach (var payload in _xssPayloads)
            {
                // Act
                // Use the XSS payload in URL parameters
                var url = $"/api/v1/search?q={Uri.EscapeDataString(payload)}";
                var response = await _client.GetAsync(url);
                var content = await response.Content.ReadAsStringAsync();
                
                // Assert
                // The response should not contain unescaped JS in the HTML
                bool hasUnescapedXss = 
                    content.Contains("<script>") || 
                    content.Contains("onerror=") ||
                    content.Contains("onmouseover=") ||
                    content.Contains("javascript:") ||
                    content.Contains("onload=") ||
                    content.Contains("onfocus=");
                
                Assert.False(hasUnescapedXss, $"Unencoded XSS payload in URL parameter response: {payload}");
                _output.WriteLine($"XSS payload correctly handled in URL parameter: {payload}");
            }
        }

        [Fact(Skip = "Integration test requiring API setup")]
        public async Task Headers_ShouldBeProperlyValidated()
        {
            // Arrange
            foreach (var payload in _xssPayloads)
            {
                // Act
                var request = new HttpRequestMessage(HttpMethod.Get, "/api/v1/profile");
                
                // Add potentially malicious headers
                request.Headers.Add("Referer", payload);
                request.Headers.Add("User-Agent", payload);
                request.Headers.Add("X-Forwarded-For", payload);
                
                var response = await _client.SendAsync(request);
                var content = await response.Content.ReadAsStringAsync();
                
                // Assert
                bool hasUnescapedXss = 
                    content.Contains("<script>") || 
                    content.Contains("onerror=") ||
                    content.Contains("onmouseover=") ||
                    content.Contains("javascript:") ||
                    content.Contains("onload=") ||
                    content.Contains("onfocus=");
                
                Assert.False(hasUnescapedXss, $"Unencoded XSS payload in header reflected in response: {payload}");
                _output.WriteLine($"XSS payload in header correctly handled: {payload}");
            }
        }

        [Fact(Skip = "Integration test requiring API setup")]
        public async Task DomBasedXss_ShouldBePreventedInClientSideCode()
        {
            // Arrange
            // This test is a placeholder because DOM-based XSS would need to be tested with a browser
            // automation tool like Selenium or Playwright
            
            // Note: This test is a placeholder for a UI-based test with Playwright
            // which would automate browser interaction to check for DOM-based XSS
            _output.WriteLine("DOM-based XSS testing would require browser automation");
            
            // Assert
            // Always passes as this is a placeholder
            Assert.True(true);
        }

        [Fact(Skip = "Integration test requiring API setup")]
        public async Task ContentSecurityPolicy_ShouldBeConfigured()
        {
            // Arrange
            var endpoints = new[]
            {
                "/",
                "/api/v1/profile",
                "/api/v1/dashboard"
            };
            
            foreach (var endpoint in endpoints)
            {
                // Act
                var response = await _client.GetAsync(endpoint);
                
                // Assert
                // Check if Content-Security-Policy header is present
                bool hasCSP = response.Headers.Contains("Content-Security-Policy");
                Assert.True(hasCSP, $"Content-Security-Policy header missing on {endpoint}");
                
                if (hasCSP)
                {
                    var cspHeader = response.Headers.GetValues("Content-Security-Policy");
                    string csp = string.Join("", cspHeader);
                    
                    // Check if CSP has default-src and script-src directives
                    Assert.Contains("default-src", csp);
                    Assert.Contains("script-src", csp);
                    
                    // Check if inline scripts are disabled
                    bool allowsUnsafeInline = csp.Contains("unsafe-inline");
                    Assert.False(allowsUnsafeInline, "CSP should not allow unsafe-inline");
                    
                    _output.WriteLine($"Content-Security-Policy correctly configured on {endpoint}");
                }
            }
        }

        [Fact(Skip = "Integration test requiring API setup")]
        public async Task ResponseShouldHaveXssProtectionHeader()
        {
            // Arrange
            var endpoints = new[]
            {
                "/",
                "/api/v1/profile",
                "/api/v1/dashboard"
            };
            
            foreach (var endpoint in endpoints)
            {
                // Act
                var response = await _client.GetAsync(endpoint);
                
                // Assert
                // Check if X-XSS-Protection header is present
                bool hasXssProtection = response.Headers.Contains("X-XSS-Protection");
                Assert.True(hasXssProtection, $"X-XSS-Protection header missing on {endpoint}");
                
                if (hasXssProtection)
                {
                    var xssHeader = response.Headers.GetValues("X-XSS-Protection");
                    string xssProtection = string.Join("", xssHeader);
                    
                    // Should be "1; mode=block"
                    Assert.Equal("1; mode=block", xssProtection);
                    
                    _output.WriteLine($"X-XSS-Protection correctly configured on {endpoint}");
                }
            }
        }
    }
} 